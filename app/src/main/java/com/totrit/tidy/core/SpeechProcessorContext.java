/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SpeechProcessor.sm
 */

package com.totrit.tidy.core;


public class SpeechProcessorContext
    extends statemap.FSMContext
{
//---------------------------------------------------------------
// Member methods.
//

    public SpeechProcessorContext(SpeechProcessor owner)
    {
        this (owner, Map1.StandBy);
    }

    public SpeechProcessorContext(SpeechProcessor owner, SpeechProcessorState initState)
    {
        super (initState);

        _owner = owner;
    }

    @Override
    public void enterStartState()
    {
        getState().entry(this);
        return;
    }

    public void answer(String sentence)
    {
        _transition = "answer";
        getState().answer(this, sentence);
        _transition = "";
        return;
    }

    public void check(String sentence)
    {
        _transition = "check";
        getState().check(this, sentence);
        _transition = "";
        return;
    }

    public void conflict(ISubject later, ISubject before)
    {
        _transition = "conflict";
        getState().conflict(this, later, before);
        _transition = "";
        return;
    }

    public void keep()
    {
        _transition = "keep";
        getState().keep(this);
        _transition = "";
        return;
    }

    public void ok()
    {
        _transition = "ok";
        getState().ok(this);
        _transition = "";
        return;
    }

    public void replace(ISubject newSub, ISubject existingSub)
    {
        _transition = "replace";
        getState().replace(this, newSub, existingSub);
        _transition = "";
        return;
    }

    public void restart()
    {
        _transition = "restart";
        getState().restart(this);
        _transition = "";
        return;
    }

    public void search(ISubject subject)
    {
        _transition = "search";
        getState().search(this, subject);
        _transition = "";
        return;
    }

    public void standby()
    {
        _transition = "standby";
        getState().standby(this);
        _transition = "";
        return;
    }

    public void start()
    {
        _transition = "start";
        getState().start(this);
        _transition = "";
        return;
    }

    public void unexpectedAnswer()
    {
        _transition = "unexpectedAnswer";
        getState().unexpectedAnswer(this);
        _transition = "";
        return;
    }

    public void wrong()
    {
        _transition = "wrong";
        getState().wrong(this);
        _transition = "";
        return;
    }

    public SpeechProcessorState getState()
        throws statemap.StateUndefinedException
    {
        if (_state == null)
        {
            throw(
                new statemap.StateUndefinedException());
        }

        return ((SpeechProcessorState) _state);
    }

    protected SpeechProcessor getOwner()
    {
        return (_owner);
    }

    public void setOwner(SpeechProcessor owner)
    {
        if (owner == null)
        {
            throw (
                new NullPointerException(
                    "null owner"));
        }
        else
        {
            _owner = owner;
        }

        return;
    }

//---------------------------------------------------------------
// Member data.
//

    transient private SpeechProcessor _owner;

    //-----------------------------------------------------------
    // Constants.
    //

    private static final long serialVersionUID = 1L;

//---------------------------------------------------------------
// Inner classes.
//

    public static abstract class SpeechProcessorState
        extends statemap.State
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected SpeechProcessorState(String name, int id)
        {
            super (name, id);
        }

        protected void entry(SpeechProcessorContext context) {}
        protected void exit(SpeechProcessorContext context) {}

        protected void answer(SpeechProcessorContext context, String sentence)
        {
            Default(context);
        }

        protected void check(SpeechProcessorContext context, String sentence)
        {
            Default(context);
        }

        protected void conflict(SpeechProcessorContext context, ISubject later, ISubject before)
        {
            Default(context);
        }

        protected void keep(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void ok(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void replace(SpeechProcessorContext context, ISubject newSub, ISubject existingSub)
        {
            Default(context);
        }

        protected void restart(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void search(SpeechProcessorContext context, ISubject subject)
        {
            Default(context);
        }

        protected void standby(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void start(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void unexpectedAnswer(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void wrong(SpeechProcessorContext context)
        {
            Default(context);
        }

        protected void Default(SpeechProcessorContext context)
        {
            throw (
                new statemap.TransitionUndefinedException(
                    "State: " +
                    context.getState().getName() +
                    ", Transition: " +
                    context.getTransition()));
        }

    //-----------------------------------------------------------
    // Member data.
    //
    }

    /* package */ static abstract class Map1
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final Map1_StandBy StandBy =
            new Map1_StandBy("Map1.StandBy", 0);
        public static final Map1_Normal Normal =
            new Map1_Normal("Map1.Normal", 1);
        public static final Map1_Checking Checking =
            new Map1_Checking("Map1.Checking", 2);
        public static final Map1_ConflictSolving ConflictSolving =
            new Map1_ConflictSolving("Map1.ConflictSolving", 3);
        public static final Map1_Search Search =
            new Map1_Search("Map1.Search", 4);
    }

    protected static class Map1_Default
        extends SpeechProcessorState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected Map1_Default(String name, int id)
        {
            super (name, id);
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class Map1_StandBy
        extends Map1_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private Map1_StandBy(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SpeechProcessorContext context)
            {
                SpeechProcessor ctxt = context.getOwner();

            ctxt.logState();
            ctxt.tipGoodbye();
            return;
        }

        @Override
        protected void start(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.tipWelcome();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class Map1_Normal
        extends Map1_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private Map1_Normal(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SpeechProcessorContext context)
            {
                SpeechProcessor ctxt = context.getOwner();

            ctxt.logState();
            return;
        }

        @Override
        protected void check(SpeechProcessorContext context, String sentence)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.tipCheck(sentence);
            }
            finally
            {
                context.setState(Map1.Checking);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void conflict(SpeechProcessorContext context, ISubject later, ISubject before)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.trySolve(later, before);
            }
            finally
            {
                context.setState(Map1.ConflictSolving);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void search(SpeechProcessorContext context, ISubject subject)
        {

            (context.getState()).exit(context);
            context.setState(Map1.Search);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void standby(SpeechProcessorContext context)
        {

            (context.getState()).exit(context);
            context.setState(Map1.StandBy);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void unexpectedAnswer(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            SpeechProcessorState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.tipUnexpectedAnswer();
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class Map1_Checking
        extends Map1_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private Map1_Checking(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SpeechProcessorContext context)
            {
                SpeechProcessor ctxt = context.getOwner();

            ctxt.logState();
            return;
        }

        @Override
        protected void ok(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.saveProvisional();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void restart(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.discardProvisional();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void standby(SpeechProcessorContext context)
        {

            (context.getState()).exit(context);
            context.setState(Map1.StandBy);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void unexpectedAnswer(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            SpeechProcessorState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.tipUnexpectedAnswer();
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        @Override
        protected void wrong(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.discardProvisional();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class Map1_ConflictSolving
        extends Map1_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private Map1_ConflictSolving(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SpeechProcessorContext context)
            {
                SpeechProcessor ctxt = context.getOwner();

            ctxt.logState();
            return;
        }

        @Override
        protected void exit(SpeechProcessorContext context)
            {
            SpeechProcessor ctxt = context.getOwner();

            ctxt.endOfConflict();
            return;
        }

        @Override
        protected void keep(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.saveProvisional();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void replace(SpeechProcessorContext context, ISubject newSub, ISubject existingSub)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.changeAndSaveProvisional(newSub, existingSub);
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void unexpectedAnswer(SpeechProcessorContext context)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.tipStartOver();
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class Map1_Search
        extends Map1_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private Map1_Search(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SpeechProcessorContext context)
            {
                SpeechProcessor ctxt = context.getOwner();

            ctxt.logState();
            return;
        }

        @Override
        protected void answer(SpeechProcessorContext context, String sentence)
        {
            SpeechProcessor ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.tipAnswer(sentence);
            }
            finally
            {
                context.setState(Map1.Normal);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void standby(SpeechProcessorContext context)
        {

            (context.getState()).exit(context);
            context.setState(Map1.StandBy);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
